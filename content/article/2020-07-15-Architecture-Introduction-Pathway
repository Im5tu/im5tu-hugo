{
    "title": "Architecture Pathway Introduction",
    "description": "A glance at some of the resources that helped me learn software architecture.",
    "tags": ["architecture"],
    "date": "2020-07-15T20:56:00+01:00",
    "categories": ["architecture", "Development"]
}

Over the past year or so, I've had the pleasure of mentoring people on their software development journeys. Some of those personnel have expressed a desire to pursue the software architect route. As it's something that I often refer to, I've decided to post a mini-pathway to help guide on some of the basics. 
<!--more-->
The majority of my learnings have come from a mixture of talented people, mistakes and good old fashion practise. The more that you practise designing systems, the better you will become, just like any other skill. I've included a brief summary from the pages linked so that you can glance at the content as you read along.

## The 10 Cloud Architecture Principals
### [Design for self healing](https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/self-healing)

In a distributed system, failures happen. Hardware can fail. The network can have transient failures. Rarely, an entire service or region may experience a disruption, but even those must be planned for. Therefore, design an application to be self healing when failures occur.

### [Make all things redundant](https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/redundancy)

A resilient application routes around failure. Identify the critical paths in your application. Is there redundancy at each point in the path? If a subsystem fails, will the application fail over to something else?

### [Mimimize coordination](https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/minimize-coordination)

Most cloud applications consist of multiple application services — web front ends, databases, business processes, reporting and analysis, and so on. To achieve scalability and reliability, each of those services should run on multiple instances. Coordination between instances limits the benefits of horizontal scale and creates bottlenecks.

### [Design to scale out](https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/scale-out)

A primary advantage of the cloud is elastic scaling — the ability to use as much capacity as you need, scaling out as load increases, and scaling in when the extra capacity is not needed. Design your application so that it can scale horizontally, adding or removing new instances as demand requires.

### [Partition around limits](https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/partition)

In the cloud, all services have limits in their ability to scale up. Limits include number of cores, database size, query throughput, and network throughput. If your system grows sufficiently large, you may hit one or more of these limits. Use partitioning to work around these limits.

### [Design for operations](https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/design-for-operations)

The cloud has dramatically changed the role of the operations team. They are no longer responsible for managing the hardware and infrastructure that hosts the application. That said, operations is still a critical part of running a successful cloud application. Involve the operations team in design and planning, to ensure the application gives them the data and insight that need to be successful.

### [Use managed services](https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/managed-services )

IaaS is like having a box of parts. You can build anything, but you have to assemble it yourself. PaaS options are easier to configure and administer. You don't need to provision VMs, set up VNets, manage patches and updates, and all of the other overhead associated with running software on a VM.

### [Use the best data store for the job](https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/use-the-best-data-store)

In any large solution, it's likely that a single data store technology won't fill all your needs. Alternatives to relational databases include key/value stores, document databases, search engine databases, time series databases, column family databases, and graph databases. Each has pros and cons, and different types of data fit more naturally into one or another.

### [Design for evolution](https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/design-for-evolution)

All successful applications change over time, whether to fix bugs, add new features, bring in new technologies, or make existing systems more scalable and resilient. If all the parts of an application are tightly coupled, it becomes very hard to introduce changes into the system. A change in one part of the application may break another part, or cause changes to ripple through the entire codebase. When services are designed to evolve, teams can innovate and continuously deliver new features.

### [Build for the needs of the business](https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/build-for-business)

This design principle may seem obvious, but it's crucial to keep in mind when designing a solution. Do you anticipate millions of users, or a few thousand? Is a one-hour application outage acceptable? Do you expect large bursts in traffic or a predictable workload? Ultimately, every design decision must be justified by a business requirement.

Different Architecture Styles
- Big Compute - https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/big-compute
- Big Data - https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/big-data
- Event Driven - https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/event-driven
- Microservices - https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices
- N-Tier Application - https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/n-tier
- Web-queue-worker - https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/web-queue-worker

Common Design Patterns
- Anti-corruption layer - https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer
- Bulkhead - https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead
- Cache-aside - https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside
- Circuit Breaker - https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker
- Command & Query Responsibility Segregation - https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs
- Compensating Transaction - https://docs.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction
- Competing Consumers - https://docs.microsoft.com/en-us/azure/architecture/patterns/competing-consumers
- Event Sourcing - https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing
- Gatekeeper - https://docs.microsoft.com/en-us/azure/architecture/patterns/gatekeeper
- Leader Election - https://docs.microsoft.com/en-us/azure/architecture/patterns/leader-election
- Queue-Based Load Leveling - https://docs.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling
- Retry - https://docs.microsoft.com/en-us/azure/architecture/patterns/retry
- Sharding - https://docs.microsoft.com/en-us/azure/architecture/patterns/sharding
- Sidecar - https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar
- Strangler - https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler
- Throttling - https://docs.microsoft.com/en-us/azure/architecture/patterns/throttling

Patterns & Practises - Stability
- Fault Tolerance in a High Volume, Distributed System - https://netflixtechblog.com/fault-tolerance-in-a-high-volume-distributed-system-91ab4faae74a
- Tips for High Availability - https://medium.com/@NetflixTechBlog/tips-for-high-availability-be0472f2599c
- Globalizing Player Accounts while Maintaining Availability - https://technology.riotgames.com/news/globalizing-player-accounts 









Distributed Systems Theory
- Understanding the 8 fallacies of Distributed Systems - https://www.simpleorientedarchitecture.com/8-fallacies-of-distributed-systems/
- CAP Theorem - https://robertgreiner.com/cap-theorem-revisited/
- How Sharding Works - https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6
- Consistent Hashing - http://www.tom-e-white.com/2007/11/consistent-hashing.html


Learning From Others
- Microservice Architecture at Medium - https://medium.engineering/microservice-architecture-at-medium-9c33805eb74f
- Automate and abstract: Lessons from Facebook on engineering for scale - https://architecht.io/lessons-from-facebook-on-engineering-for-scale-f5716f0afc7a




OTHER
- Workload Isolation Using Shuffle-Sharding - https://aws.amazon.com/builders-library/workload-isolation-using-shuffle-sharding/
- Avoiding Insurmountable Queue Backlogs - https://aws.amazon.com/builders-library/avoiding-insurmountable-queue-backlogs/
- Implementing Health Checks - https://aws.amazon.com/builders-library/implementing-health-checks/
- Monoliths and Microservices - https://medium.com/@SkyscannerEng/monoliths-and-microservices-8c65708c3dbf
